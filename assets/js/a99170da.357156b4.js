"use strict";(self.webpackChunkvsc_docu=self.webpackChunkvsc_docu||[]).push([[9648],{7014:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var i=t(5893),o=t(1151);const r={},s="Execution Environment",c={id:"VSC documentation/Technology/Execution Environment",title:"Execution Environment",description:"VSC executes transactions and smart contract logic using a deterministic, high-throughput runtime built on modern blockchain architecture standards. This section outlines the structure of the protocol\u2019s state machine, execution layer, and supported tooling.",source:"@site/docs/VSC documentation/Technology/02_Execution Environment.md",sourceDirName:"VSC documentation/Technology",slug:"/VSC documentation/Technology/Execution Environment",permalink:"/docs/VSC documentation/Technology/Execution Environment",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Cross-Chain Architecture",permalink:"/docs/VSC documentation/Technology/Cross-Chain Architecture"},next:{title:"FAQ",permalink:"/docs/discussions/FAQ"}},a={},l=[{value:"Core State Machine Structure",id:"core-state-machine-structure",level:2},{value:"Transaction Validation",id:"transaction-validation",level:2},{value:"Smart Contract Execution Environment",id:"smart-contract-execution-environment",level:2},{value:"Language Support and Tooling",id:"language-support-and-tooling",level:2},{value:"Execution Characteristics",id:"execution-characteristics",level:2}];function d(n){const e={h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"execution-environment",children:"Execution Environment"}),"\n",(0,i.jsx)(e.p,{children:"VSC executes transactions and smart contract logic using a deterministic, high-throughput runtime built on modern blockchain architecture standards. This section outlines the structure of the protocol\u2019s state machine, execution layer, and supported tooling."}),"\n",(0,i.jsx)(e.h2,{id:"core-state-machine-structure",children:"Core State Machine Structure"}),"\n",(0,i.jsxs)(e.p,{children:["VSC follows a ",(0,i.jsx)(e.strong,{children:"rollup-like design"}),", where transactions are processed in batches and applied to a shared chain state. This approach provides a clean separation between execution and consensus, allowing the system to:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Deterministic state transitions"}),"\n",(0,i.jsx)(e.li,{children:"Efficient batch processing"}),"\n",(0,i.jsx)(e.li,{children:"Modular execution logic separated from core consensus"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This design allows VSC to evolve independently at the execution layer without disrupting consensus logic or external integrations."}),"\n",(0,i.jsx)(e.h2,{id:"transaction-validation",children:"Transaction Validation"}),"\n",(0,i.jsxs)(e.p,{children:["Transaction validation and state updates in VSC rely on a ",(0,i.jsx)(e.strong,{children:"Byzantine Fault Tolerant (BFT)-like structure"}),". Validators process incoming transactions and apply state changes only after a supermajority agreement is reached. This ensures:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Fault tolerance in the presence of misbehaving or offline nodes"}),"\n",(0,i.jsx)(e.li,{children:"Agreement on the order of valid transactions"}),"\n",(0,i.jsx)(e.li,{children:"Consistency and security guarantees typical of BFT consensus models"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This ensures the network can maintain operational integrity even when a portion of validators are compromised or fail."}),"\n",(0,i.jsx)(e.h2,{id:"smart-contract-execution-environment",children:"Smart Contract Execution Environment"}),"\n",(0,i.jsxs)(e.p,{children:["VSC supports smart contracts compiled to ",(0,i.jsx)(e.strong,{children:"WebAssembly (WASM)"}),", enabling developers to build on-chain logic in a platform-agnostic format. WASM contracts run in a sandboxed environment that enforces:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Deterministic behavior"}),"\n",(0,i.jsx)(e.li,{children:"Stack and memory limits"}),"\n",(0,i.jsx)(e.li,{children:"Isolation from the host runtime"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Developers benefit from consistent execution outcomes without needing to learn a domain-specific language."}),"\n",(0,i.jsx)(e.h2,{id:"language-support-and-tooling",children:"Language Support and Tooling"}),"\n",(0,i.jsx)(e.p,{children:"VSC currently supports contract development in:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Golang"})," \u2013 Suitable for lower-level or system-focused contracts"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"AssemblyScript"})," \u2013 A TypeScript-like language with a lightweight footprint and WebAssembly compatibility"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Contracts can be compiled to WASM and deployed to the VSC network using SDKs or developer tooling provided by the protocol.\nSupporting familiar and performant languages lowers the barrier to entry and reduces time-to-deploy for new applications."}),"\n",(0,i.jsx)(e.h2,{id:"execution-characteristics",children:"Execution Characteristics"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["All smart contract interactions are ",(0,i.jsx)(e.strong,{children:"feeless"}),", supported by Hive\u2019s resource credit model."]}),"\n",(0,i.jsxs)(e.li,{children:["Contract execution is ",(0,i.jsx)(e.strong,{children:"deterministic"}),", enforced through WASM's runtime constraints."]}),"\n",(0,i.jsx)(e.li,{children:"VSC\u2019s internal APIs provide access to core blockchain functions, external asset states, and vault logic from within smart contracts."}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,o.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},1151:(n,e,t)=>{t.d(e,{Z:()=>c,a:()=>s});var i=t(7294);const o={},r=i.createContext(o);function s(n){const e=i.useContext(r);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);