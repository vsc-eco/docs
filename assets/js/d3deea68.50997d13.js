"use strict";(self.webpackChunkvsc_docu=self.webpackChunkvsc_docu||[]).push([[8380],{5478:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var n=t(5893),i=t(1151);const r={},a="Traders",o={id:"Roles/Traders",title:"Traders",description:"Execute Cross-Chain Asset Swaps.",source:"@site/docs/Roles/06_Traders.md",sourceDirName:"Roles",slug:"/Roles/Traders",permalink:"/docs/Roles/Traders",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"dApp Users",permalink:"/docs/Roles/dApp users"},next:{title:"Arbitrageurs",permalink:"/docs/Roles/Arbitrageurs"}},c={},l=[];function d(e){const s={em:"em",h1:"h1",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"traders",children:"Traders"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.em,{children:"Execute Cross-Chain Asset Swaps."})}),"\n",(0,n.jsx)(s.p,{children:"Traders are users who wish to exchange one native asset for another, such as Bitcoin for Ethereum, without relying on centralized exchanges, wrapped assets, or synthetic tokens. VSC enables this through its in-protocol liquidity layer, which facilitates direct swaps between native assets in a decentralized, trust-minimized way."}),"\n",(0,n.jsx)(s.p,{children:"When a trader initiates a swap, they send their native asset (e.g., BTC) into the VSC's vault secured on the Bitcoin mainnet by the VSC validator system. VSC then processes the transaction by drawing from available liquidity pools and routing the output asset (e.g., ETH) to the swapper\u2019s destination wallet. This happens transparently and securely across chains, while the swapper only needs to sign a single transaction from their wallet."}),"\n",(0,n.jsx)(s.p,{children:"VSC ensures that traders always receive native assets on both ends of the swap. This is a core difference from systems that rely on wrapped or bridged assets, which introduce significant trust and custodial risks. Instead, VSC maintains a decentralized smart contract-based system that can interact natively with external chains using inbound and outbound vaults and smart routing logic. Every swap is atomic and either completes fully or fails, eliminating the risk of partial fills or stuck funds."}),"\n",(0,n.jsx)(s.p,{children:"Traders benefit from:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Simplicity"}),": Users don\u2019t need to understand the technical details of how cross-chain communication works. They just initiate a swap."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Security"}),": Funds remain non-custodial throughout the process. VSC's validator network oversees the process to ensure integrity."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Transparency"}),": All swap logic and movement of funds happen on-chain, verifiable by anyone."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Native settlement"}),": Swappers always end up with actual native tokens (e.g., native BTC or native ETH), never wrapped variants."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Decentralization"}),": No need to rely on third parties or central liquidity sources. The protocol handles everything."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Trading/Swapping on VSC is a key use case for users looking to interact with multiple blockchain ecosystems from one unified system without sacrificing the benefits of decentralization, custody, and asset integrity. As liquidity grows, swaps become faster, deeper, and more efficient \u2014 supporting not only individuals but also dApps, payment systems, and arbitrageurs."})]})}function h(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},1151:(e,s,t)=>{t.d(s,{Z:()=>o,a:()=>a});var n=t(7294);const i={},r=n.createContext(i);function a(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);